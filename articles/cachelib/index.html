<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
  
  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">
  <meta name="description" content="学点新知识">
  <meta name="keywords" content=",C++">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="编程经验分享小站">
  <meta name="msapplication-starturl" content="https://www.unidy.cn/articles/cachelib/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="编程经验分享小站">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/unidy.png">

  <title>CacheLib 学习笔记 | 编程经验分享小站</title>
  <link rel="shortcut icon" href="/images/unidy.png">
  
  <meta name="description" content="学点新知识">
<meta property="og:type" content="article">
<meta property="og:title" content="CacheLib 学习笔记">
<meta property="og:url" content="https://www.unidy.cn/articles/cachelib/">
<meta property="og:site_name" content="编程经验分享小站">
<meta property="og:description" content="学点新知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cachelib.org/assets/images/Navy_Architecture_overview-3fcba60db4e31d50cd4dd7ea560de0c4.png">
<meta property="og:image" content="https://cachelib.org/assets/images/Hybrid_Cache_find-ff4b025b03a1b7e43197062810d5c574.png">
<meta property="og:image" content="https://cachelib.org/assets/images/Hybrid_Cache_allocate-b198d86843a876795fc2b398ea42a936.png">
<meta property="og:image" content="https://www.unidy.cn/images/kangaroo-1.png">
<meta property="og:image" content="https://www.unidy.cn/images/kangaroo-2.png">
<meta property="og:image" content="https://www.unidy.cn/images/chained.png">
<meta property="og:image" content="https://cachelib.org/assets/images/hashtable-bbb7241416549634ca94eacf582a764a.png">
<meta property="og:image" content="https://cachelib.org/assets/images/Navy_Architecture_overview-3fcba60db4e31d50cd4dd7ea560de0c4.png">
<meta property="article:published_time" content="2022-10-16T00:00:00.000Z">
<meta property="article:modified_time" content="2023-01-31T08:44:48.987Z">
<meta property="article:author" content="UNIDY">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cachelib.org/assets/images/Navy_Architecture_overview-3fcba60db4e31d50cd4dd7ea560de0c4.png">

  
  <meta property="article:published_time" content="Sun Oct 16 2022 00:00:00 GMT+0000">
  <meta property="article:modified_time" content="Tue Jan 31 2023 08:44:48 GMT+0000">
  

  
  <link rel="canonical" href="https://www.unidy.cn/articles/cachelib/">
  

  
  

  
  
  

  
<link rel="stylesheet" href="https://unpkg.com/mdui@1.0.1/dist/css/mdui.min.css">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css">

<meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-indigo mdui-theme-accent-pink">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
    <div class="mdui-toolbar mdui-color-theme">
      <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
      <a href="/" class="mdui-typo-headline">编程经验分享小站</a>
      <div class="mdui-toolbar-spacer"></div>
      <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
      
    </div>
  </header>
  <div class="mdui-dialog" id="search">
    
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
    
  </div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
    <div class="mdui-grid-tile">
      <img src="/images/banner.png" style="height: 160px;">
      <img src="/images/unidy.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
      <div class="mdui-grid-tile-actions">
        <div class="mdui-grid-tile-text">
          <div class="mdui-grid-tile-title">UNIDY</div>
          <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i>Stay Hungry, Stay Foolish.</div>
        </div>
        
      </div>
    </div>

    <div class="mdui-list" mdui-collapse="{accordion: true}">
      <a href="/" class="mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
        <div class="mdui-list-item-content">主页</div>
      </a>
      <div class="mdui-collapse-item">
        <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
          <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">inbox</i>
          <div class="mdui-list-item-content">归档</div>
          <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
        </div>
        <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
          
          <a class="mdui-ripple sidebar_archives-link" href="/archives/2022/11/">十一月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/10/">十月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/09/">九月 2022<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/07/">七月 2022<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/06/">六月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/01/">一月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/06/">六月 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/01/">一月 2021<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/11/">十一月 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/06/">六月 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/03/">三月 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/02/">二月 2020<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/01/">一月 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/12/">十二月 2019<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/11/">十一月 2019<span class="mdui-ripple sidebar_archives-count">2</span></a>
          
        </div>
      </div>
      <div class="mdui-collapse-item">
        <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
          <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
          <div class="mdui-list-item-content">分类</div>
          <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
        </div>
        <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
          
          <a class="mdui-ripple sidebar_archives-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%8E%A7/">代码控<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AE%85/">技术宅<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/">碎碎念<span class="mdui-ripple sidebar_archives-count">11</span></a>
          
        </div>
      </div>
      <div class="mdui-collapse-item">
        <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
          <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
          <div class="mdui-list-item-content">标签</div>
          <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
        </div>
        <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
          
          <a class="mdui-ripple sidebar_archives-none-link" href="/tags/Android/" rel="tag">Android<span class="mdui-ripple sidebar_archives-none-count">1</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/C/" rel="tag">C++<span class="mdui-ripple sidebar_archives-none-count">3</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/JavaScript/" rel="tag">JavaScript<span class="mdui-ripple sidebar_archives-none-count">2</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/JetBrains/" rel="tag">JetBrains<span class="mdui-ripple sidebar_archives-none-count">2</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/Kotlin/" rel="tag">Kotlin<span class="mdui-ripple sidebar_archives-none-count">1</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/PyCharm/" rel="tag">PyCharm<span class="mdui-ripple sidebar_archives-none-count">1</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/Python/" rel="tag">Python<span class="mdui-ripple sidebar_archives-none-count">1</span></a><a class="mdui-ripple sidebar_archives-none-link" href="/tags/%E9%9A%8F%E6%83%B3/" rel="tag">随想<span class="mdui-ripple sidebar_archives-none-count">13</span></a>
          
        </div>
      </div>
      <a href="/about" class="mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
        <div class="mdui-list-item-content">关于</div>
      </a>
    </div>

    <div class="mdui-divider"></div>

    <div class="mdui-list" mdui-collapse="{accordion: true}">
      
      <a href="/downloads" class="mdui-list-item mdui-ripple">资源下载</a>
      
      <a href="https://thuinfo.net/" class="mdui-list-item mdui-ripple">THUInfo</a>
      
      <a href="https://www.saiblo.net/" class="mdui-list-item mdui-ripple">Saiblo</a>
      
      <div class="mdui-collapse-item">
        <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
          <div class="mdui-list-item-content">友情链接</div>
          <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
        </div>
        <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
          
          <a href="https://www.dilant.cn/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">迪兰特的小屋</a>
          
          <a href="https://ashitemaru.github.io/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Ashitemaru</a>
          
          <a href="https://zcy.moe/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">猫猫窝</a>
          
          
        </div>
      </div>
    </div>
  </aside>
  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    
    <header class="mdui-card-media">
      <img src="/images/random/material-7.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">CacheLib 学习笔记</div>
		  
            <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2022-10-16 / <i class="iconfont">&#xe601;</i> UNIDY</div>
	      
        </div>
      </div>
      <div class="mdui-card-menu">
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>
          <ul class="mdui-menu" id="qrcode">
            
              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">在移动端上查看</a></li>
            
            <li class="mdui-menu-item" disabled>
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAAB5UlEQVR42u3aQXLDMAgF0Nz/0u0BMpY/Inbr8LTqNHGk5wUDgtfPV6wXBgYGBgYGBsa/Ybzi9f7U0S8cffP9+60zYGBgDGOchLaAsX7q6OitM2BgYIxkHAW49ZbrkNoBn+yLgYGBETCStC8JqRgYGBj3MJJgmqeJGBgYGJ0idn3cdeFa/c0La3EMDIwHMvJL+ev+vrW/gYGB8ShGecSheImWNztvnRnBwMB4FCMPfNVEcO+SLqdiYGDMYeQXXustq0dMWp6FIhYDA2MAo9NW7AyzXp7hYmBgfAWjWmTuJY7Jp+XmKAYGxjBGdV3RBM1fBAYGxjTGOuzutQ0613mX1OIYGBgPZ3x2m87QRvVVYmBgTGN8KhHcSxP3dsTAwJjDyFO66qd7hevHilgMDIwvYlSHt/bC69513sl5MDAwBjPylmQ17CbIQhqKgYExkpGH4L1hi85TGBgYGH1A9XXkqeEhDwMDYwxjb5yi2oxMUsm8jYqBgTGN0RlaTZK/attg/SwGBsZkRn88Itk4Kk3j/2NgYMxkbLYSt4YtOsOyGBgYGFVGNbAmIXWziMXAwMAoDlhUL/2r6SYGBsZMxl7QPNmsPWSGgYGBUQ151WGvaii/qb+BgYHxKMZzFwYGBgYGBgbGn65fHtrpFubZVEIAAAAASUVORK5CYII=">
            </li>
          </ul>
        
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="http://service.weibo.com/share/share.php?appkey=&title=CacheLib 学习笔记&url=https://www.unidy.cn/articles/cachelib/&pic=https://www.unidy.cn/images/unidy.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到微博</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=CacheLib 学习笔记&url=https://www.unidy.cn/articles/cachelib/&via=UNIDY" target="_blank" class="mdui-ripple">分享到Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://www.unidy.cn/articles/cachelib/" target="_blank" class="mdui-ripple">分享到Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=https://www.unidy.cn/articles/cachelib/" target="_blank" class="mdui-ripple">分享到Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.unidy.cn/articles/cachelib/&title=CacheLib 学习笔记" target="_blank" class="mdui-ripple">分享到LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="http://connect.qq.com/widget/shareqq/index.html?site=编程经验分享小站&title=CacheLib 学习笔记&summary=The personal blog of UNIDY&pics=https://www.unidy.cn/images/unidy.png&url=https://www.unidy.cn/articles/cachelib/" target="_blank" class="mdui-ripple">分享到QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=https://www.unidy.cn/articles/cachelib/&text=CacheLib 学习笔记" target="_blank" class="mdui-ripple">分享到Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
	
    <div class="mdui-card-content mdui-typo">
      <h1 id="CacheLib-解决的问题"><a href="#CacheLib-解决的问题" class="headerlink" title="CacheLib 解决的问题"></a>CacheLib 解决的问题</h1><table>
<thead>
<tr>
<th>挑战</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>需要大容量缓存系统</td>
<td>DRAM 与 flash 混合式存储</td>
</tr>
<tr>
<td>存储对象规模差异大</td>
<td>根据对象规模采取不同策略</td>
</tr>
<tr>
<td>不加特殊控制，容易 OOM</td>
<td>动态监控并管理系统资源</td>
</tr>
<tr>
<td>无法高效缓存空结果</td>
<td>提供 negative caching 支持</td>
</tr>
<tr>
<td>更新结构化对象字段较麻烦</td>
<td>支持直接更新结构化对象字段</td>
</tr>
<tr>
<td>服务重启影响缓存性能</td>
<td>支持热重启</td>
</tr>
</tbody></table>
<h1 id="CacheLib-基本概念"><a href="#CacheLib-基本概念" class="headerlink" title="CacheLib 基本概念"></a>CacheLib 基本概念</h1><h2 id="Item-与-Handle"><a href="#Item-与-Handle" class="headerlink" title="Item 与 Handle"></a><code>Item</code> 与 <code>Handle</code></h2><p><code>Item</code> 是表示缓存对象的逻辑单元，占据一定的内存空间。为了防止 <code>Item</code> 被访问时失效（被删除、逐出等），CacheLib 禁止直接访问 <code>Item</code>，而是要求通过 <code>Handle</code> 对 <code>Item</code> 进行访问，且对 <code>Item</code> 进行引用计数。只有一个 <code>Item</code> 被引用的次数为 0 时，它才有可能被删除或逐出。</p>
<p>每个 <code>Item</code> 存储时，均需附加 32 字节的元信息。</p>
<p><code>Slab</code> 是缓存分配的物理单元，大小为 4MB。因此，每个 <code>Item</code> 所需空间不得超过 4MB。<code>Item</code> 可以串联起来，用来存储更大的对象。</p>
<p>代码：<code>allocator/Handle.h</code></p>
<h2 id="MemoryPool"><a href="#MemoryPool" class="headerlink" title="MemoryPool"></a><code>MemoryPool</code></h2><p>CacheLib 允许将 Cache 划分为不超过 64 个 <code>MemoryPool</code>。每个 <code>MemoryPool</code> 可以根据应用场景，分别存放不同种类的对象。因为缓存对象的替换只会发生在 <code>MemoryPool</code> 内部，<code>MemoryPool</code> 之间则是相互隔离的，所以可以起到提升命中率的作用。</p>
<p>此外，相比于用一整块 Cache 存储各类对象，让每个 <code>MemoryPool</code> 内部存放大小相近的对象，在提高空间利用率、减少内存碎片方面也有好处。</p>
<h2 id="HybridCache"><a href="#HybridCache" class="headerlink" title="HybridCache"></a>HybridCache</h2><p>HybridCache 将缓存从 DRAM 存储扩展到 NVM 存储。由于 NVM 存储设备价格一般比 DRAM 低，且通常能提供更大规模的存储，通过 HybridCache，系统可以在扩大缓存空间的同时，控制甚至降低设备成本。</p>
<p>尽管 HybridCache 将缓存分为两个层级，但只有处于 DRAM 中的 <code>Item</code> 才允许由外界直接访问。按照 CacheLib 的设计，NVM 的存储细节应当对用户透明。<code>MemoryPool</code> 等设计也只在 DRAM 存储层级内适用。</p>
<p>这一设计思想很像操作系统中 memory swapping 的设计。</p>
<h2 id="Navy"><a href="#Navy" class="headerlink" title="Navy"></a>Navy</h2><p>Navy 是一个缓存引擎，为 HybridCache 服务，旨在基于 SSD 的物理特性做针对性的优化。SSD 最大的特点在于块式存储，且擦除次数有限，因此 Navy 应避免频繁写入，且需要做好磨损均衡。</p>
<p>为此，Navy 需要对小 <code>Item</code> 与大 <code>Item</code> 采用不同的存储策略。Navy 内部分为两个引擎：Small Item Engine 与 Large Item Engine，并根据 <code>Item</code> 的大小选择合适的引擎分别处理。</p>
<p>一个 SSD 页面的大小为 4KB，而区分大小 <code>Item</code> 的界限为 2KB。对于小 <code>Item</code> 的缓存（SOC），一个页面中可以存放多个 <code>Item</code>。CacheLib 会根据 <code>Item</code> key 的哈希选择具体的页面，而在页面内采用 FIFO 的替换策略。此外，对于每个页面，CacheLib 会在 DRAM 内维护一个快速查询器（<code>BloomFilter</code>），用于在缓存缺失时避免不必要的文件读取，提高查询效率。对于大 <code>Item</code> 的缓存（LOC），CacheLib 会在 DRAM 中为每个 <code>Item</code> 维护一个索引。</p>
<p>此外，为提升 Navy 引擎的并发性，所有的请求都应是异步的。这就要求 Navy 内部实现一个异步调度器。</p>
<p><img src="https://cachelib.org/assets/images/Navy_Architecture_overview-3fcba60db4e31d50cd4dd7ea560de0c4.png" alt="img"></p>
<h1 id="示例代码学习：Set-up-a-simple-dram-cache"><a href="#示例代码学习：Set-up-a-simple-dram-cache" class="headerlink" title="示例代码学习：Set up a simple dram cache"></a>示例代码学习：<a href="https://cachelib.org/docs/Cache_Library_User_Guides/Set_up_a_simple_cache">Set up a simple dram cache</a></h1><h2 id="类型梳理"><a href="#类型梳理" class="headerlink" title="类型梳理"></a>类型梳理</h2><ul>
<li><p>一共有四种 <code>CacheTrait</code>，每个 <code>CacheTrait</code> 由 <code>MMType</code>、<code>AccessType</code>、<code>AccessTypeLocks</code> 三个要素构成。</p>
</li>
<li><p><code>Cache = CacheAllocator&lt;CacheTrait&gt;</code></p>
</li>
<li><p><code>Cache::Config = CacheAllocatorConfig&lt;Cache&gt;</code></p>
<ul>
<li>可以从 <code>Cache::Config</code> 构造出 <code>Cache</code></li>
</ul>
</li>
<li><p><code>Cache::Item = CacheItem&lt;CacheTrait&gt;</code></p>
</li>
<li><p><code>Cache::Key = Cache::Item::Key</code></p>
<ul>
<li><code>Key</code> 实际上是 <code>folly::StringPiece</code> 的派生类，但重载了比较函数，目的是在短 key 的比较上取得优势</li>
</ul>
</li>
<li><p><code>Cache::NvmCache = NvmCache&lt;Cache&gt;</code></p>
</li>
<li><p><code>Cache::NvmCacheConfig = NvmCache::Config</code></p>
<ul>
<li>可以从 <code>Cache</code> 和 <code>NvmCacheConfig</code> 构造出 <code>NvmCache</code></li>
</ul>
</li>
<li><p><code>NvmCache::Item = Cache::Item</code></p>
</li>
<li><p>我认为 CacheLib 如此依赖模板来实现静态多态的目的是，尽可能提升运行时效率。</p>
</li>
</ul>
<h2 id="接口梳理"><a href="#接口梳理" class="headerlink" title="接口梳理"></a>接口梳理</h2><ul>
<li><p><code>ReadHandle find(Key key)</code>：读 Cache</p>
</li>
<li><p><code>WriteHandle allocate(PoolId poolId, Key key, u32 size, u32 ttlSecs = 0)</code>：分配一块缓存；分配得到的 <code>WriteHandle</code> 不会立刻生效，需要配合 <code>insert</code> 或 <code>insertOrReplace</code> 接口才能写入 Cache</p>
</li>
<li><p><code>bool insert(const WriteHandle &amp;handle)</code>：将 <code>WriteHandle</code> 写入 Cache；若 key 已存在，则拒绝写入，并返回失败</p>
</li>
<li><p><code>WriteHandle insertOrReplace(const WriteHandle &amp;handle)</code>：将 <code>WriteHandle</code> 写入 Cache；若替换了某个已有 <code>Item</code>，则将其以 <code>WriteHandle</code> 的形式返回</p>
</li>
<li><p><code>WriteHandle findToWrite(Key key)</code>：查找指定 key 的 <code>Item</code>，并返回可用于更新的 <code>WriteHandle</code></p>
</li>
</ul>
<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><blockquote>
<p>对于每一个接口，都有非常多的情形和边界条件需要考虑。这里仅仅列出各接口的大致执行流程。</p>
</blockquote>
<h2 id="find"><a href="#find" class="headerlink" title="find()"></a><code>find()</code></h2><p><code>find()</code> 接口首先会调用 <code>findFastInternal()</code> 接口，在 DRAM 内快速查询目标 <code>key</code>。实施查询时，会采用该缓存实例的 <code>CacheTrait</code> 中定义的 <code>AccessType</code> 进行查询。（CacheLib 内置的四种 <code>CacheTrait</code> 的 <code>AccessType</code> 均为 <code>ChainedHashTable</code>。）</p>
<p>如果未能在 DRAM 中找到目标 <code>key</code>，且 HybridCache 可用，则调用 <code>NvmCache</code> 的 <code>find</code> 接口进一步查询。需要注意的是，由于 NVM 查询的异步性，这种情况下返回的 <code>Handle</code> 是一个 Future。</p>
<p><img src="https://cachelib.org/assets/images/Hybrid_Cache_find-ff4b025b03a1b7e43197062810d5c574.png" alt="img"></p>
<h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate()"></a><code>allocate()</code></h2><p>CacheLib 会根据 <code>Item</code> 的大小，将 <code>Item</code> 划入相应的 <code>AllocationClass</code>。</p>
<p><code>allocate()</code> 接口首先会尝试在 <code>MemoryPool</code> 内寻找空闲内存。若内存已满，则会尝试调用 <code>findEviction()</code> 接口，逐出某个现有 <code>Item</code>。</p>
<p>如果成功分配了空闲内存，CacheLib 就会用这块内存封装出一个 <code>WriteHandle</code>，供上层使用。</p>
<p>若启用 HybridCache，分配操作的流程如下图所示。</p>
<p><img src="https://cachelib.org/assets/images/Hybrid_Cache_allocate-b198d86843a876795fc2b398ea42a936.png" alt="img"></p>
<h2 id="insertOrReplace"><a href="#insertOrReplace" class="headerlink" title="insertOrReplace()"></a><code>insertOrReplace()</code></h2><blockquote>
<p>由于 HybridCache 场景下，<code>insert()</code> 接口不可用，所以这里只分析 <code>insertOrReplace()</code> 接口的实现。</p>
<p>注意，由于内存不足而发生的逐出发生在 <code>allocate()</code> 接口中。这里的 replace 指的是插入同 key <code>Item</code> 时的替换。</p>
</blockquote>
<p>CacheLib 的插入过程有两步要做：</p>
<ul>
<li><p>更新内存管理（memory management）信息（例如，如果采用 LRU 策略管理缓存，那就需要更新对应的 <code>LruList</code>，见 <code>allocator/MMLru.h</code> 相关代码）</p>
</li>
<li><p>将 <code>Item</code> 写入缓存（实际的插入操作）</p>
</li>
</ul>
<p>在将 <code>Item</code> 写入缓存时，如果有某个同 key <code>Item</code> 被替换出来，那也需要在内存管理信息中将这个被替换出来的 <code>Item</code> 记录去掉。</p>
<p>如果被替换出来的 <code>Item</code> 在 NVM 中也有一份副本，那么需要将它在 NVM 中的那份副本也删掉。</p>
<h2 id="findToWrite"><a href="#findToWrite" class="headerlink" title="findToWrite()"></a><code>findToWrite()</code></h2><p><code>findToWrite()</code> 接口的实现与 <code>find()</code> 的基本一样，缺省表现是会额外调用一次 <code>invalidateNvm()</code> 接口，使其在 NVM 中失效。</p>
<h1 id="Kangaroo"><a href="#Kangaroo" class="headerlink" title="Kangaroo"></a>Kangaroo</h1><h2 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h2><p>Kangaroo 的核心目标是，对于在 flash 上缓存海量小 <code>Item</code> 的场景，针对 flash 设备的物理特性，对缓存系统进行优化，从而在 DRAM 使用量和 flash 写次数之间达成平衡。</p>
<p>Kangaroo 的思路是，将 log-structured 和 set-associative 缓存设计结合使用，取长补短。前者的优势在于降低 flash 的写次数，后者的优势在于降低 DRAM 的使用量。</p>
<p>Kangaroo 构造了一个三级缓存架构：DRAM Cache（全部在内存中，容量&lt;1%）、KLog（数据在 Flash 中，索引在内存中，容量≈5%）、KSet（数据在 Flash 中，容量≈95%）。查询和插入操作的流程如下图所示。</p>
<p><img src="/images/kangaroo-1.png" alt="img"></p>
<p><img src="/images/kangaroo-2.png" alt="img"></p>
<p>为了降低 flash 的写次数，Kangaroo 还使用了以下技巧：</p>
<ul>
<li><p>批量写入——从 KLog 逐出一项数据到 KSet 时，会顺带将 KLog 中所有属于同一组的数据一并搬到 KSet 中</p>
</li>
<li><p>选择性接纳——为 KSet 一次接纳的数据量设定下限，若 KLog 一次无法提供足够多的数据，则 KSet 会拒绝这次写入</p>
</li>
<li><p>RRIParoo——将 RRIP 策略应用于 KSet 的设计中，从而提升缓存命中率</p>
</li>
</ul>
<p>尚未在 CacheLib 主分支中找到 Kangaroo 相关代码。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>内存管理的代码主要位于 <code>allocator/memory</code> 目录下。</p>
<p>每个 <code>MemoryPool</code> 内部独立管理内存，每个 <code>MemoryPool</code> 可指定一组 <code>AllocationClass</code>。</p>
<p>进行内存分配时，首先在 <code>MemoryPool</code> 的 <code>AllocationClass</code> 当中找到一个刚好能分配目标空间的一级。这里，CacheLib 保证维护的 <code>AllocationClass</code> 规模列表是有序的，从而可以二分查找。找到合适的 <code>AllocationClass</code> 后，即可进行内存分配。</p>
<p><code>Slab</code> 是内存管理的基本单元。一个 <code>Slab</code> 内可以有多个 allocations。<code>AllocationClass</code> 的最小规模为 64B，最大规模为 4MB。</p>
<h2 id="Slab-管理与回收——AllocationClass-视角"><a href="#Slab-管理与回收——AllocationClass-视角" class="headerlink" title="Slab 管理与回收——AllocationClass 视角"></a><code>Slab</code> 管理与回收——<code>AllocationClass</code> 视角</h2><p><code>AllocationClass</code> 内维护了以下成员：</p>
<ul>
<li><p><code>freeSlabs_</code>，空 <code>Slab</code> 列表。<code>AllocationClass</code> 本身无法构造 <code>Slab</code>，因此这些空 <code>Slab</code> 是由上层的 <code>MemoryPool</code> 添加的。</p>
</li>
<li><p><code>allocatedSlabs_</code>，已分配的 <code>Slab</code> 列表。一个 <code>Slab</code> 被分配后，它的地址就会写入 <code>allocatedSlabs_</code> 中。当出于 rebalance 或 resize 的原因，需要从 <code>AllocationClass</code> 释放空间时，<code>allocatedSlabs_</code> 中的 <code>Slab</code> 可能被删除。</p>
</li>
<li><p><code>freedAllocations_</code>，已回收的 allocations 列表。一个 allocation 被回收后，就会记录在 <code>freedAllocations_</code> 中。下次分配 allocation 时，会首先尝试回收利用 <code>freedAllocations_</code> 中的 allocation。</p>
</li>
<li><p><code>currSlab_</code>，当前活跃的 <code>Slab</code>。<code>Slab</code> 是切成一份一份 allocations 之后提供给上层的。在分配 allocation 的过程中，一个 <code>Slab</code> 可能还没消耗完。这时，这个 <code>Slab</code> 就处于活跃状态，下次分配 allocation 时也将从该活跃的 <code>Slab</code> 下手。</p>
</li>
<li><p><code>currOffset_</code>，当前活跃 <code>Slab</code> 已切分的偏移量。下次分配 allocation 时，就从当前活跃 <code>Slab</code> 的 <code>currOffset_</code> 偏移处开始分配。</p>
</li>
<li><p><code>slabReleaseAllocMap_</code>，维护将被释放的 <code>Slab</code> 内仍存留的有效 allocations 的下标，用于辅助 <code>Slab</code> 释放的过程。原则上，只有当一个 <code>Slab</code> 内不存在有效 allocation 时，这个 <code>Slab</code> 才能真正意义上被删除。因此，这是一个“异步”的过程，需要引入一些成员变量来维护。</p>
</li>
</ul>
<p>一个典型的生命周期如下所示：</p>
<ol>
<li><p>系统启动时，<code>AllocationClass</code> 内尚无可用空间，<code>MemoryPool</code> 将一个 <code>Slab</code> 添加到该 <code>AllocationClass</code> 的 <code>freeSlabs_</code> 中。</p>
</li>
<li><p><code>AllocationClass</code> 从 <code>freeSlabs_</code> 中取出一个 <code>Slab</code>，添加到 <code>allocatedSlabs_</code> 中，并将其标记为 <code>currSlab_</code>。</p>
</li>
<li><p><code>AllocationClass</code> 从 <code>currSlab_</code> 中切出一段 allocation，用于给上层系统分配 <code>Item</code>，同时更新 <code>currOffset_</code>。</p>
</li>
<li><p>上层系统删除 <code>Item</code> 时，<code>AllocationClass</code> 也将对应的 allocation 回收，放入 <code>freedAllocations_</code> 中，以供未来复用。</p>
</li>
<li><p>上层系统对 <code>MemoryPool</code> 进行 rebalance 或 resize 时，<code>AllocationClass</code> 会从 <code>freeSlabs_</code> 和 <code>allocatedSlabs_</code> 中删掉一些 <code>Slab</code>。如果 <code>Slab</code> 中仍存在有效的 allocation，<code>AllocationClass</code> 会告知上层系统。</p>
</li>
</ol>
<h2 id="多级-freeSlabs-设计"><a href="#多级-freeSlabs-设计" class="headerlink" title="多级 freeSlabs_ 设计"></a>多级 <code>freeSlabs_</code> 设计</h2><p><code>SlabAllocator</code>、<code>MemoryPool</code> 和 <code>AllocationClass</code> 均有 <code>freeSlabs_</code> 这一成员，用于维护当前可分配的空闲 <code>Slab</code> 列表。每一级只能支配属于自己的 <code>freeSlabs_</code>，具体而言：</p>
<ul>
<li><p><code>AllocationClass</code> 只能支配 <code>AllocationClass</code> 内部的空闲 <code>Slab</code>。如果当前 <code>freeSlabs_</code> 为空，该 <code>AllocationClass</code> 将无法分配新的 <code>Slab</code>。</p>
</li>
<li><p><code>MemoryPool</code> 可以从自己的 <code>freeSlabs_</code> 中拿出一些空闲 <code>Slab</code>，加入其下属 <code>AllocationClass</code> 的 <code>freeSlabs_</code> 中，也可以利用自己的 <code>freeSlabs_</code> 列表在 <code>AllocationClass</code> 之间进行<a href="https://cachelib.org/docs/Cache_Library_Architecture_Guide/slab_rebalancing/">重平衡</a>操作。</p>
</li>
<li><p><code>SlabAllocator</code> 直接管理系统内的所有 <code>Slab</code>，也可以从自己的 <code>freeSlabs_</code> 中取出一些 <code>Slab</code> 加入某个 <code>MemoryPool</code> 的 <code>freeSlabs_</code> 中。此外，<code>SlabAllocator</code> 还可以通过自己的 <code>freeSlabs_</code> 在 <code>MemoryPool</code> 之间重新分配空间。</p>
</li>
</ul>
<p>我认为这一设计有如下优势：</p>
<ul>
<li><p>每一级有自己的空闲 <code>Slab</code> 列表，能够较为灵活地调整内部空间分配。</p>
</li>
<li><p>当上级存储要求下级存储释放一些空间时，如果下级存储的 <code>freeSlabs_</code> 中有空闲 <code>Slab</code>，可直接释放。</p>
</li>
</ul>
<h2 id="动态调整流程分析"><a href="#动态调整流程分析" class="headerlink" title="动态调整流程分析"></a>动态调整流程分析</h2><p>CacheLib 会定时对 <code>MemoryPool</code> 中的 <code>AllocationClass</code> 进行重平衡的操作。用户也可能手动调整 <code>MemoryPool</code> 的大小。这些动态调整内存分配的行为均有可能触发 <code>SlabRelease</code> 操作。</p>
<p><code>SlabRelease</code> 会直接要求某个 <code>AllocationClass</code> 让出一个 <code>Slab</code>，具体的情形如下：</p>
<ul>
<li><p>若 <code>freeSlabs_</code> 中就有空闲 <code>Slab</code>，则直接提供。</p>
</li>
<li><p>否则，在 <code>allocatedSlabs_</code> 中随机选择一个 <code>Slab</code>，准备将其释放。原则上，只有当一个 <code>Slab</code> 内不存在有效 allocation 时，这个 <code>Slab</code> 才能被释放。因此，需要执行以下流程（代码实现见 <code>AllocationClass::pruneFreeAllocs()</code> 和 <code>CacheAllocator::releaseSlabImpl()</code>）：</p>
<ul>
<li>根据该 <code>AllocationClass</code> 的 <code>freedAllocations_</code> 列表，标记出该 <code>Slab</code> 内还存有哪些 <code>activeAllocations</code>；</li>
<li>对于这些 <code>activeAllocations</code>，首先尝试在 <code>MemoryPool</code> 内部重新分配空间，将这些旧的 allocations 重新写入缓存；</li>
<li>如果不成功，则将其逐出缓存。</li>
</ul>
</li>
</ul>
<p>由于 b. 的存在，这一流程对缓存中的内存碎片进行了整理，提升了内存空间的利用率。</p>
<h2 id="侵入式-SList-与高效的-CompressedPtr"><a href="#侵入式-SList-与高效的-CompressedPtr" class="headerlink" title="侵入式 SList 与高效的 CompressedPtr"></a>侵入式 <code>SList</code> 与高效的 <code>CompressedPtr</code></h2><blockquote>
<p>这是我第一次知道侵入式链表的概念，颠覆了我对链表的传统观念。</p>
</blockquote>
<p><code>AllocationClass</code> 内使用一个侵入式链表来维护已回收的 allocations。采用侵入式链表可以直接在待回收的内存上<strong>原地</strong>存储下一节点的地址，能够节省空间并提高效率，是非常巧妙的设计。</p>
<p>用于表示 allocation 的地址也不采用原始指针，而是重新定义了一个 <code>CompressedPtr</code>，采用一个 32 位整数表示 <code>Slab</code> 编号和 allocation 编号两部分信息。这里做一个简单的计算：一个 <code>Slab</code> 内最多分配 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.739ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 6956.7 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="4D" d="M132 622Q125 629 121 631T105 634T62 637H29V683H135Q221 683 232 682T249 675Q250 674 354 398L458 124L562 398Q666 674 668 675Q671 681 683 682T781 683H887V637H854Q814 636 803 634T785 622V61Q791 51 802 49T854 46H887V0H876Q855 3 736 3Q605 3 596 0H585V46H618Q660 47 669 49T688 61V347Q688 424 688 461T688 546T688 613L687 632Q454 14 450 7Q446 1 430 1T410 7Q409 9 292 316L176 624V606Q175 588 175 543T175 463T175 356L176 86Q187 50 261 46H278V0H269Q254 3 154 3Q52 3 37 0H29V46H46Q78 48 98 56T122 69T132 86V622Z"></path><path data-c="42" d="M131 622Q124 629 120 631T104 634T61 637H28V683H229H267H346Q423 683 459 678T531 651Q574 627 599 590T624 512Q624 461 583 419T476 360L466 357Q539 348 595 302T651 187Q651 119 600 67T469 3Q456 1 242 0H28V46H61Q103 47 112 49T131 61V622ZM511 513Q511 560 485 594T416 636Q415 636 403 636T371 636T333 637Q266 637 251 636T232 628Q229 624 229 499V374H312L396 375L406 377Q410 378 417 380T442 393T474 417T499 456T511 513ZM537 188Q537 239 509 282T430 336L329 337H229V200V116Q229 57 234 52Q240 47 334 47H383Q425 47 443 53Q486 67 511 104T537 188Z" transform="translate(917,0)"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2125,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(2625,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3625,0)"><g data-mml-node="mi"><path data-c="42" d="M131 622Q124 629 120 631T104 634T61 637H28V683H229H267H346Q423 683 459 678T531 651Q574 627 599 590T624 512Q624 461 583 419T476 360L466 357Q539 348 595 302T651 187Q651 119 600 67T469 3Q456 1 242 0H28V46H61Q103 47 112 49T131 61V622ZM511 513Q511 560 485 594T416 636Q415 636 403 636T371 636T333 637Q266 637 251 636T232 628Q229 624 229 499V374H312L396 375L406 377Q410 378 417 380T442 393T474 417T499 456T511 513ZM537 188Q537 239 509 282T430 336L329 337H229V200V116Q229 57 234 52Q240 47 334 47H383Q425 47 443 53Q486 67 511 104T537 188Z"></path></g></g><g data-mml-node="mo" transform="translate(4610.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(5666.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container> 个 allocations，那就可以用余下的 16 位整数表示 <code>Slab</code> 编号。一个 <code>Slab</code> 的大小为 4MB，这样就能表示 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="20.281ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 8964.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="4D" d="M132 622Q125 629 121 631T105 634T62 637H29V683H135Q221 683 232 682T249 675Q250 674 354 398L458 124L562 398Q666 674 668 675Q671 681 683 682T781 683H887V637H854Q814 636 803 634T785 622V61Q791 51 802 49T854 46H887V0H876Q855 3 736 3Q605 3 596 0H585V46H618Q660 47 669 49T688 61V347Q688 424 688 461T688 546T688 613L687 632Q454 14 450 7Q446 1 430 1T410 7Q409 9 292 316L176 624V606Q175 588 175 543T175 463T175 356L176 86Q187 50 261 46H278V0H269Q254 3 154 3Q52 3 37 0H29V46H46Q78 48 98 56T122 69T132 86V622Z"></path><path data-c="42" d="M131 622Q124 629 120 631T104 634T61 637H28V683H229H267H346Q423 683 459 678T531 651Q574 627 599 590T624 512Q624 461 583 419T476 360L466 357Q539 348 595 302T651 187Q651 119 600 67T469 3Q456 1 242 0H28V46H61Q103 47 112 49T131 61V622ZM511 513Q511 560 485 594T416 636Q415 636 403 636T371 636T333 637Q266 637 251 636T232 628Q229 624 229 499V374H312L396 375L406 377Q410 378 417 380T442 393T474 417T499 456T511 513ZM537 188Q537 239 509 282T430 336L329 337H229V200V116Q229 57 234 52Q240 47 334 47H383Q425 47 443 53Q486 67 511 104T537 188Z" transform="translate(917,0)"></path></g></g><g data-mml-node="mo" transform="translate(2347.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(3347.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(4915.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5971.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7471.1,0)"><g data-mml-node="mi"><path data-c="47" d="M56 342Q56 428 89 500T174 615T283 681T391 705Q394 705 400 705T408 704Q499 704 569 636L582 624L612 663Q639 700 643 704Q644 704 647 704T653 705H657Q660 705 666 699V419L660 413H626Q620 419 619 430Q610 512 571 572T476 651Q457 658 426 658Q401 658 376 654T316 633T254 592T205 519T177 411Q173 369 173 335Q173 259 192 201T238 111T302 58T370 31T431 24Q478 24 513 45T559 100Q562 110 562 160V212Q561 213 557 216T551 220T542 223T526 225T502 226T463 227H437V273H449L609 270Q715 270 727 273H735V227H721Q674 227 668 215Q666 211 666 108V6Q660 0 657 0Q653 0 639 10Q617 25 600 42L587 54Q571 27 524 3T406 -22Q317 -22 238 22T108 151T56 342Z"></path><path data-c="42" d="M131 622Q124 629 120 631T104 634T61 637H28V683H229H267H346Q423 683 459 678T531 651Q574 627 599 590T624 512Q624 461 583 419T476 360L466 357Q539 348 595 302T651 187Q651 119 600 67T469 3Q456 1 242 0H28V46H61Q103 47 112 49T131 61V622ZM511 513Q511 560 485 594T416 636Q415 636 403 636T371 636T333 637Q266 637 251 636T232 628Q229 624 229 499V374H312L396 375L406 377Q410 378 417 380T442 393T474 417T499 456T511 513ZM537 188Q537 239 509 282T430 336L329 337H229V200V116Q229 57 234 52Q240 47 334 47H383Q425 47 443 53Q486 67 511 104T537 188Z" transform="translate(785,0)"></path></g></g></g></g></svg></mjx-container> 范围的缓存地址。因此，这种表示方式非常高效。</p>
<h2 id="Slab-与-SlabHeader"><a href="#Slab-与-SlabHeader" class="headerlink" title="Slab 与 SlabHeader"></a><code>Slab</code> 与 <code>SlabHeader</code></h2><p>每个 <code>Slab</code> 需要维护自身的 <code>poolId</code>、<code>classId</code> 等元信息，这些元信息用一个 <code>SlabHeader</code> 结构存储。CacheLib 的策略是，将整块内存分为两部分，前面一小部分依次存放各个 <code>SlabHeader</code>，剩余部分用于分配 <code>Slab</code>。</p>
<p>这就要求 <code>SlabAllocator</code> 在构造时就估计好这个切分的界限。由于 <code>Slab</code> 与 <code>SlabHeader</code> 的大小都是已知的（分别为 4MB 和 7B），只要知道内存总量，这一估计并不困难，具体实现见 <code>SlabAllocator::computeSlabMemoryStart()</code>。</p>
<p><code>SlabHeader</code> 结构在定义时注明了 <code>__attribute__((__packed__))</code>，从而能更紧凑地利用内存空间。</p>
<h1 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h1><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p>每个 <code>Item</code> 所占空间不得超过一个 <code>Slab</code> 的大小（4MB）。为了支持更大对象的存储，CacheLib 引入链式存储机制，通过串联多个 <code>Item</code> 的方式实现这一需求。</p>
<p>CacheLib 的设计是，让一个普通的 <code>CacheItem</code> 充当祖先节点，另外一些 <code>CacheChainedItem</code> 串成一个单链表，“接在”这个祖先节点之后。每个 <code>CacheChainedItem</code> 均需存储祖先节点的地址，以便知道自己祖先是谁，也要存储后继节点的地址，以实现链表的功能。整个缓存系统内还要维护一张大表（使用 <code>CacheTrait::AccessType</code> 指定的容器实现），用于根据祖先节点查找链表的起点。</p>
<p><img src="/images/chained.png" alt="img"></p>
<h2 id="CacheChainedItem-内存布局"><a href="#CacheChainedItem-内存布局" class="headerlink" title="CacheChainedItem 内存布局"></a><code>CacheChainedItem</code> 内存布局</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">| --------------------- |</span><br><span class="line">| AccessHook            |</span><br><span class="line">| MMHook                |</span><br><span class="line">| RefCountWithFlags     |</span><br><span class="line">| creationTime_         |</span><br><span class="line">| expiryTime_           |</span><br><span class="line">| --------------------- |</span><br><span class="line">|  K | size_            |</span><br><span class="line">|  A | ---------------- |</span><br><span class="line">|  l |       | keyData  | &lt;-- sizeof(CompressedPtr)</span><br><span class="line">|  l |       | -------- |</span><br><span class="line">|  o |       | P | hook | &lt;-- sizeof(SlistHook&lt;ChainedItem&gt;)</span><br><span class="line">|  c | data_ | a | data |</span><br><span class="line">|  a |       | y |      |</span><br><span class="line">|  t |       | l |      |</span><br><span class="line">|  i |       | o |      |</span><br><span class="line">|  o |       | a |      |</span><br><span class="line">|  n |       | d |      |</span><br><span class="line">| --------------------- |</span><br></pre></td></tr></table></figure>

<p><code>CacheChainedItem</code> 与 <code>CacheItem</code> 在内存布局上大体相同，都有五个元信息字段，都使用 <code>KAllocation</code> 维护对象数据。</p>
<blockquote>
<p>在这里简单补充一下 <code>KAllocation</code> 的结构和优化细节。</p>
<p><code>KAllocation</code> 需要维护两部分内容：<code>Item</code> 的 key 与 <code>Item</code> 的 payload。两者均为可变长数据，且连续地存储在 <code>data_</code> 字段内，这就需要 <code>KAllocation</code> 额外维护两者的数据长度。</p>
<p><code>KAllocation</code> 巧妙地使用一个 32 位整数字段维护两个长度：用前 8 位表示 key 的长度，后 24 位表示 payload 的长度，以达到压缩空间的目的。</p>
</blockquote>
<p>和普通的 <code>CacheItem</code> 不同之处在于：</p>
<ul>
<li><p><code>CacheChainedItem</code> 将祖先节点的指针作为 key，从而可以根据祖先节点的地址找到 <code>CacheChainedItem</code>；</p>
</li>
<li><p><code>CacheChainedItem</code> 需要利用 payload 的前几个字节存储后继节点的指针，以实现链表的功能。</p>
</li>
</ul>
<p>以上两个指针均用 <code>CompressedPtr</code> 实现，用于减小空间开销。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><code>CacheItem</code> 内有一个字段 <code>ref_</code>，用来维护该 <code>CacheItem</code> 的引用计数等信息，用一个 32 位整数表示。这里也用到了压位技巧，此处不展开。</p>
<p>以下两种情形会计入引用：</p>
<ul>
<li><p>通过 <code>ReadHandle</code> 或 <code>WriteHandle</code> 被用户使用；</p>
</li>
<li><p>作为 <code>CacheChainedItem</code> 被父节点引用。</p>
</li>
</ul>
<p>这张表格描述了引用计数更新的规律：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>提供给用户使用</th>
<th>父节点引用</th>
</tr>
</thead>
<tbody><tr>
<td>计数增加</td>
<td><code>Handle</code> 构造时</td>
<td><code>Item</code> 进入链表时</td>
</tr>
<tr>
<td>计数减少</td>
<td><code>Handle</code> 析构时</td>
<td><code>Item</code> 离开链表时</td>
</tr>
</tbody></table>
<h2 id="Handle-做到的与没做到的"><a href="#Handle-做到的与没做到的" class="headerlink" title="Handle 做到的与没做到的"></a><code>Handle</code> 做到的与没做到的</h2><p>根据 CacheLib 代码注释的描述（见 <code>allocator/CacheItem.h</code>），<code>Handle</code> 的作用是保证引用计数的正确性，类似 <code>std::shared_ptr</code>。可仔细阅读代码后，我发现 <code>Handle</code> 并不如智能指针那样“智能”。首先，当 <code>Item</code> 进入和离开链表时，<code>Item</code> 的引用计数还是要由上层的 <code>CacheAllocator</code> 手动更新。其次，<code>Handle</code> 也不会在构造时自动将 <code>Item</code> 的引用计数加一，还是需要交由上层接口自行控制。</p>
<blockquote>
<p>参见 <code>CacheAllocator::acquire()</code>，<code>CacheAllocator</code> 的其他接口如果想要从 <code>Item</code> 构造 <code>Handle</code>，应当通过这一方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CacheTrait&gt;</span><br><span class="line"><span class="keyword">typename</span> CacheAllocator&lt;CacheTrait&gt;::WriteHandle</span><br><span class="line">CacheAllocator&lt;CacheTrait&gt;::<span class="built_in">acquire</span>(Item* it) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!it)) {</span><br><span class="line">    <span class="keyword">return</span> WriteHandle{};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SCOPE_FAIL { stats_.numRefcountOverflow.<span class="built_in">inc</span>(); };</span><br><span class="line"></span><br><span class="line">  <span class="built_in">incRef</span>(*it);</span><br><span class="line">  <span class="keyword">return</span> WriteHandle{it, *<span class="keyword">this</span>};</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当然，<code>Handle</code> 还是做到了一些事情的。比如，<code>Handle</code> 确实会在析构时将 <code>Item</code> 的引用计数减一。另外，<code>Handle</code> 禁用了拷贝构造和拷贝赋值，避免拷贝造成引用计数的管理混乱。对 CacheLib 内部实现而言，<code>Handle</code> 也许并不够“智能”。但对用户而言，<code>Handle</code> 确实做到了用户透明的引用计数控制。</p>
<h1 id="结构化存储——以-Map-为例"><a href="#结构化存储——以-Map-为例" class="headerlink" title="结构化存储——以 Map 为例"></a>结构化存储——以 <code>Map</code> 为例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Map</code> 基于链式存储实现。CacheLib 用一个祖先节点存储映射关系（采用哈希表），用剩余的后继节点存储映射值，映射关系里只存储映射值的地址。整个 <code>Map</code> 构成一个大的 CacheLib 存储对象。</p>
<p><img src="https://cachelib.org/assets/images/hashtable-bbb7241416549634ca94eacf582a764a.png" alt="img"></p>
<p>CacheLib 引入了一个 <code>BufferManager</code>，用于管理 Value Storage 部分可分配的空间。需要注意的是，<code>BufferManager</code> 并不拥有内存，也不占据存储空间，而更像是一个工具类，辅助 <code>Map</code> 进行内存空间的使用。</p>
<p><code>Map</code> 有两个重要字段：<code>hashtable_</code> 与 <code>bufferManager_</code>。接下来两节将分别介绍这两个字段的实现细节。</p>
<h2 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h2><p><code>hashtable_</code> 用于维护这个 <code>Map</code> 的映射关系，它存储于祖先节点的内存空间中。<code>hashtable_</code> 的类型为 <code>TypedHandle&lt;HashTable&gt;</code>，这意味着它与一般的 <code>Handle</code> 本质相同，只是内存被解释为 <code>HashTable</code> 类型，方便编程。</p>
<p><code>HashTable</code> 采用了一个开放地址的实现方式，只用一段连续的地址空间即可完成。<code>HashTable</code> 的主体数据部分为一个 <code>Entry[]</code>，每个 <code>Entry</code> 表示一个键值映射，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FOLLY_PACK_ATTR</span> Entry {</span><br><span class="line">  Key key{};</span><br><span class="line">  BufferAddr addr{<span class="literal">nullptr</span>};</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> addr == <span class="literal">nullptr</span>; }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setNull</span><span class="params">()</span> </span>{ addr = <span class="literal">nullptr</span>; }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p><code>Key</code> 可以是自定义类型，前提是长度固定，且不能引用堆上数据（意味着不能用 <code>std::string</code>）。</p>
<p><code>BufferAddr</code> 用来描述值在 Value Storage 中的地址，同样采用了压位的技巧，前 22 位用于表示在 <code>Buffer</code> 内的位置（0～4MB），后 10 位用于表示在第几块 <code>Buffer</code> 内。</p>
<p>当 <code>Handle</code> 存储空间用满时，<code>HashTable</code> 会尝试在 <code>MemoryPool</code> 内重新申请一个空间，并将现有的映射关系重哈希、迁移过去。</p>
<p>其余部分实现与传统的 <code>HashTable</code> 差不多，此处不再展开。</p>
<h2 id="BufferManager"><a href="#BufferManager" class="headerlink" title="BufferManager"></a><code>BufferManager</code></h2><p><code>BufferManager</code> 内保存了指向 <code>CacheAllocator</code> 实例以及祖先节点的指针，此外还有一个 <code>std::vector&lt;Item*&gt; buffers_</code>，依次存放每块 <code>Buffer</code> 所对应的 <code>Item</code> 的指针。</p>
<p>当 <code>Map</code> 需要添加一组新的键值对时，<code>BufferManager</code> 首先会遍历每一块 <code>Buffer</code>，询问是否有足够的空间。若有，则写入对应的值，并更新映射关系。若没有，<code>Map</code> 会让 <code>BufferManager</code> 申请一块新的 <code>CacheChainedItem</code> 后，重新给出一个可分配的地址，写入待添加的值，并由 <code>Map</code> 更新映射关系。</p>
<p>由于每次需要分配的空间长度并不固定，<code>Buffer</code> 内采用了较为简单的分配策略：直接在上一次分配的地址之后分配下一个地址。即使因删除而存在空洞，也不会直接复用，而只有在必要的情况下才会重新整理压缩 <code>Buffer</code> 内分配的空间。</p>
<h1 id="Navy-异步调度器"><a href="#Navy-异步调度器" class="headerlink" title="Navy 异步调度器"></a>Navy 异步调度器</h1><h2 id="设计层次"><a href="#设计层次" class="headerlink" title="设计层次"></a>设计层次</h2><p>Navy 引擎中，数据主要存放于 SSD 上，因此数据的读写是一个异步的过程。为此，Navy 需要实现一个异步调度器。</p>
<p>Navy 引入了一个 <code>Driver</code> 层，向上提供一系列异步接口，向下对接存储部件，并负责控制异步调度器。</p>
<p>在异步调度器的部分，Navy 定义了一个抽象类 <code>JobScheduler</code>，系统中默认使用的是派生类 <code>OrderedThreadPoolJobScheduler</code>，实现细节之后分析。</p>
<p>在 <code>Driver</code> 层之下，就是具体的存储引擎。由于 <code>Driver</code> 层已经处理好异步调度，存储引擎的代码都是在线程池中执行的，因此只需按同步的方式实现存储引擎接口即可。</p>
<p><img src="https://cachelib.org/assets/images/Navy_Architecture_overview-3fcba60db4e31d50cd4dd7ea560de0c4.png" alt="img"></p>
<blockquote>
<p>一例看懂 <code>Driver</code>、<code>JobScheduler</code> 与 <code>Engine</code> 的关系（注意代码中的注释）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Driver 向上提供异步接口</span></span><br><span class="line"><span class="function">Status <span class="title">Driver::lookupAsync</span><span class="params">(HashedKey hk, LookupCallback cb)</span> </span>{</span><br><span class="line">  lookupCount_.<span class="built_in">inc</span>();</span><br><span class="line">  <span class="built_in">XDCHECK</span>(cb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Driver 将异步任务传给 JobScheduler</span></span><br><span class="line">  scheduler_-&gt;<span class="built_in">enqueueWithKey</span>(</span><br><span class="line">      [<span class="keyword">this</span>, cb = std::<span class="built_in">move</span>(cb), hk, skipLargeItemCache = <span class="literal">false</span>]() <span class="keyword">mutable</span> {</span><br><span class="line">        <span class="comment">// 该函数将在新线程上执行 </span></span><br><span class="line">        Buffer value;</span><br><span class="line">        Status status{Status::NotFound};</span><br><span class="line">        <span class="keyword">if</span> (!skipLargeItemCache) {</span><br><span class="line">          <span class="comment">// largeItemCache_ 是一个 Engine 实例</span></span><br><span class="line">          <span class="comment">// Driver 驱动下层引擎执行 IO 任务</span></span><br><span class="line">          status = largeItemCache_-&gt;<span class="built_in">lookup</span>(hk, value);</span><br><span class="line">          <span class="keyword">if</span> (status == Status::Retry) {</span><br><span class="line">            <span class="keyword">return</span> JobExitCode::Reschedule;</span><br><span class="line">          }</span><br><span class="line">          skipLargeItemCache = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (status == Status::NotFound) {</span><br><span class="line">          <span class="comment">// smallItemCache_ 是另一个 Engine 实例</span></span><br><span class="line">          <span class="comment">// Driver 驱动下层引擎执行 IO 任务</span></span><br><span class="line">          status = smallItemCache_-&gt;<span class="built_in">lookup</span>(hk, value);</span><br><span class="line">          <span class="keyword">if</span> (status == Status::Retry) {</span><br><span class="line">            <span class="keyword">return</span> JobExitCode::Reschedule;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cb) {</span><br><span class="line">          <span class="comment">// 通过回调函数通知异步任务完成</span></span><br><span class="line">          <span class="built_in">cb</span>(status, hk, std::<span class="built_in">move</span>(value));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateLookupStats</span>(status);</span><br><span class="line">        <span class="keyword">return</span> JobExitCode::Done;</span><br><span class="line">      },</span><br><span class="line">      <span class="string">"lookup"</span>,</span><br><span class="line">      JobType::Read,</span><br><span class="line">      hk.<span class="built_in">keyHash</span>());</span><br><span class="line">  <span class="keyword">return</span> Status::Ok;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a><code>JobScheduler</code></h2><p><code>JobScheduler</code> 是异步调度器的抽象类，任何一个具体的异步调度器，都需要实现 <code>JobScheduler</code> 定义的五个抽象方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JobScheduler</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">JobScheduler</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uses @key to schedule job on one of available workers. Jobs can be</span></span><br><span class="line">  <span class="comment">// ordered by their key based on their enqueue order,  if the scheduler</span></span><br><span class="line">  <span class="comment">// supports it.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">enqueueWithKey</span><span class="params">(Job job,</span></span></span><br><span class="line"><span class="params"><span class="function">                              folly::StringPiece name,</span></span></span><br><span class="line"><span class="params"><span class="function">                              JobType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint64_t</span> key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue a job for execution. No ordering guarantees are made for these</span></span><br><span class="line">  <span class="comment">// jobs.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">enqueue</span><span class="params">(Job job, folly::StringPiece name, JobType type)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// guarantees that all enqueued jobs are finished and blocks until then.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">finish</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// visits each available counter for the visitor to take appropriate action.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getCounters</span><span class="params">(<span class="type">const</span> CounterVisitor&amp; visitor)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>其中，最关键的接口是 <code>enqueueWithKey</code> 与 <code>enqueue</code>，它们将 <code>job</code> 加入调度队列中，交给对应的线程池执行。</p>
<p>Navy 实现了两个派生类：<code>ThreadPoolJobScheduler</code> 与 <code>OrderedThreadPoolJobScheduler</code>。下面分别介绍这两个派生类。</p>
<blockquote>
<p>如果只想知道 <code>JobScheduler</code> 的总体设计，而不关心具体实现细节，建议去看<a href="https://cachelib.org/docs/Cache_Library_Architecture_Guide/navy_architecture_overview#job-scheduler">官方教程</a>。那里对两个不同的派生类做了模糊处理（压根就没提），虽然有些事实性错误，但更容易理解一些。</p>
</blockquote>
<h3 id="ThreadPoolJobScheduler"><a href="#ThreadPoolJobScheduler" class="headerlink" title="ThreadPoolJobScheduler"></a><code>ThreadPoolJobScheduler</code></h3><p><code>ThreadPoolJobScheduler</code> 为读和写任务分别创建了一个线程池（<code>ThreadPoolExecutor</code>）。每当有新任务加入时，<code>ThreadPoolJobScheduler</code> 就会根据任务的类别，将其移动到对应的线程池中。</p>
<p>默认设置下，每个线程池有 32 个线程。每个线程都有对应的 <code>JobQueue</code> 实例，用于维护自己需要处理的任务队列。</p>
<p>线程池拿到任务后，就会选择一个线程，将任务加入它的 <code>JobQueue</code> 实例中，交给该线程执行。</p>
<p>这里补充交代一些细节：</p>
<ol>
<li><p>线程池选择线程的依据是，如果是用 <code>enqueueWithKey</code> 接口添加的任务，那就根据 <code>key</code> 的模选择，否则就轮流；</p>
</li>
<li><p>部分类型的任务（<code>JobType::Reclaim</code> 和 <code>JobType::Flush</code>）可以“插队”，从而优先被线程执行；</p>
</li>
<li><p>为保证线程安全，在需要变更任务列表时，<code>JobQueue</code> 会用互斥锁进行保护；</p>
</li>
<li><p>为避免线程空转，<code>JobQueue</code> 引入一个 <code>std::condition_variable</code>，在任务执行完毕时陷入阻塞状态，等到下一个任务被加入时重新唤醒。</p>
</li>
</ol>
<h3 id="OrderedThreadPoolJobScheduler"><a href="#OrderedThreadPoolJobScheduler" class="headerlink" title="OrderedThreadPoolJobScheduler"></a><code>OrderedThreadPoolJobScheduler</code></h3><p><code>OrderedThreadPoolJobScheduler</code> 在满足 <code>ThreadPoolJobScheduler</code> 的<strong>一切特性</strong>的同时，保证了 <code>key</code> 相同的任务执行时的有序性。</p>
<p>它的核心想法是，引入一个“缓冲带”，在接受一个新任务之前，检查是否有同样 <code>key</code> 的任务正在执行或等待执行中。如有，将其追加到该 <code>key</code> 的缓冲队列中。否则，直接交给线程池去执行。</p>
<p>为了高效实现这一机制，<code>OrderedThreadPoolJobScheduler</code> 引入大量桶（默认值为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container> 个）。每个桶内维护一个缓冲队列，根据 <code>key</code> 的模选择对应的桶。</p>
<h2 id="兼容新的存储介质"><a href="#兼容新的存储介质" class="headerlink" title="兼容新的存储介质"></a>兼容新的存储介质</h2><p>Navy 引入 <code>Driver</code> 层的这一设计，让我们能够进行扩展以兼容新的存储介质。</p>
<p>还是以 <code>Driver::lookupAsync</code> 这一接口为例，注意它加入调度器的具体任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Driver::lookupAsync</span><span class="params">(HashedKey hk, LookupCallback cb)</span> </span>{</span><br><span class="line">  lookupCount_.<span class="built_in">inc</span>();</span><br><span class="line">  <span class="built_in">XDCHECK</span>(cb);</span><br><span class="line"></span><br><span class="line">  scheduler_-&gt;<span class="built_in">enqueueWithKey</span>(</span><br><span class="line">      [<span class="keyword">this</span>, cb = std::<span class="built_in">move</span>(cb), hk, skipLargeItemCache = <span class="literal">false</span>]() <span class="keyword">mutable</span> {</span><br><span class="line">        Buffer value;</span><br><span class="line">        Status status{Status::NotFound};</span><br><span class="line">        <span class="keyword">if</span> (!skipLargeItemCache) {</span><br><span class="line">          status = largeItemCache_-&gt;<span class="built_in">lookup</span>(hk, value);</span><br><span class="line">          <span class="keyword">if</span> (status == Status::Retry) {</span><br><span class="line">            <span class="keyword">return</span> JobExitCode::Reschedule;</span><br><span class="line">          }</span><br><span class="line">          skipLargeItemCache = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (status == Status::NotFound) {</span><br><span class="line">          status = smallItemCache_-&gt;<span class="built_in">lookup</span>(hk, value);</span><br><span class="line">          <span class="keyword">if</span> (status == Status::Retry) {</span><br><span class="line">            <span class="keyword">return</span> JobExitCode::Reschedule;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cb) {</span><br><span class="line">          <span class="built_in">cb</span>(status, hk, std::<span class="built_in">move</span>(value));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateLookupStats</span>(status);</span><br><span class="line">        <span class="keyword">return</span> JobExitCode::Done;</span><br><span class="line">      },</span><br><span class="line">      <span class="string">"lookup"</span>,</span><br><span class="line">      JobType::Read,</span><br><span class="line">      hk.<span class="built_in">keyHash</span>());</span><br><span class="line">  <span class="keyword">return</span> Status::Ok;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>它大体上进行了这样的流程：先查找 <code>largeItemCache_</code>，如果未命中再查找 <code>smallItemCache_</code>，如果仍未命中则报告未找到。</p>
<p>假如我们希望引入新的存储介质，如 S3，那么只需自行实现该介质的相应接口，并在 <code>Driver</code> 层相应的执行流程中调用即可（例如，若 SSD 缓存中无法命中，则前往 S3 缓存进一步查找）。</p>

      
        <blockquote class="mdui-m-t-5">
          
          <strong>本文链接：</strong><a href="https://www.unidy.cn/articles/cachelib/">https://www.unidy.cn/articles/cachelib/</a>
        </blockquote>
	  
      
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%8E%A7/">代码控</a>
      
      
        <a class="mdui-ripple article_tags-none-link" href="/tags/C/" rel="tag">C++</a>
      
    </footer>
    
  </article>
  
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/articles/node-tracing/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/articles/tuimian/">
        下一篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>


  <div id="comment" class="mdui-m-t-5">
    <div class="vcomment"></div>
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js"></script>
<script src="https://unpkg.com/leancloud-storage@4.12.2/dist/av-min.js"></script>
<script src="https://unpkg.com/valine@1.4.18/dist/Valine.min.js"></script>
<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  var notify = 'false' === 'true';
  var verify = 'false' === 'true';
  new Valine({
    av: AV,
    el: '.vcomment',
    notify: notify,
    verify: verify,
    appId: "ewlT3sErBcbbAdwPXrhxRNfg-gzGzoHsz",
    appKey: "MQgeLEsEGHvbeG6SjqBaiUad",
    placeholder: "一起来评论呀~",
    pageSize: '',
    avatar: 'mp',
    lang: '',
    guest_info: guest_info
  });
</script>

  </div>



  <div style="position: fixed !important; right: 16px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">format_list_numbered</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CacheLib-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">CacheLib 解决的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CacheLib-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">CacheLib 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-%E4%B8%8E-Handle"><span class="toc-number">2.1.</span> <span class="toc-text">Item 与 Handle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MemoryPool"><span class="toc-number">2.2.</span> <span class="toc-text">MemoryPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HybridCache"><span class="toc-number">2.3.</span> <span class="toc-text">HybridCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Navy"><span class="toc-number">2.4.</span> <span class="toc-text">Navy</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9ASet-up-a-simple-dram-cache"><span class="toc-number">3.</span> <span class="toc-text">示例代码学习：Set up a simple dram cache</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A2%B3%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">类型梳理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%A2%B3%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">接口梳理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#find"><span class="toc-number">4.1.</span> <span class="toc-text">find()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#allocate"><span class="toc-number">4.2.</span> <span class="toc-text">allocate()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insertOrReplace"><span class="toc-number">4.3.</span> <span class="toc-text">insertOrReplace()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#findToWrite"><span class="toc-number">4.4.</span> <span class="toc-text">findToWrite()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kangaroo"><span class="toc-number">5.</span> <span class="toc-text">Kangaroo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87"><span class="toc-number">5.1.</span> <span class="toc-text">核心目标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.1.</span> <span class="toc-text">基本设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slab-%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9B%9E%E6%94%B6%E2%80%94%E2%80%94AllocationClass-%E8%A7%86%E8%A7%92"><span class="toc-number">6.2.</span> <span class="toc-text">Slab 管理与回收——AllocationClass 视角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7-freeSlabs-%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.3.</span> <span class="toc-text">多级 freeSlabs_ 设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">动态调整流程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%B5%E5%85%A5%E5%BC%8F-SList-%E4%B8%8E%E9%AB%98%E6%95%88%E7%9A%84-CompressedPtr"><span class="toc-number">6.5.</span> <span class="toc-text">侵入式 SList 与高效的 CompressedPtr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slab-%E4%B8%8E-SlabHeader"><span class="toc-number">6.6.</span> <span class="toc-text">Slab 与 SlabHeader</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">7.</span> <span class="toc-text">链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.1.</span> <span class="toc-text">总体设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CacheChainedItem-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">7.2.</span> <span class="toc-text">CacheChainedItem 内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handle-%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%8E%E6%B2%A1%E5%81%9A%E5%88%B0%E7%9A%84"><span class="toc-number">7.4.</span> <span class="toc-text">Handle 做到的与没做到的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94%E4%BB%A5-Map-%E4%B8%BA%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">结构化存储——以 Map 为例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.2.</span> <span class="toc-text">映射关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BufferManager"><span class="toc-number">8.3.</span> <span class="toc-text">BufferManager</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Navy-%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">Navy 异步调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1"><span class="toc-number">9.1.</span> <span class="toc-text">设计层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JobScheduler"><span class="toc-number">9.2.</span> <span class="toc-text">JobScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolJobScheduler"><span class="toc-number">9.2.1.</span> <span class="toc-text">ThreadPoolJobScheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OrderedThreadPoolJobScheduler"><span class="toc-number">9.2.2.</span> <span class="toc-text">OrderedThreadPoolJobScheduler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%96%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8"><span class="toc-number">9.3.</span> <span class="toc-text">兼容新的存储介质</span></a></li></ol></li></ol></li>
    </ul>
  </div>

<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js"></script>
<script src='https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.10/clipboard.min.js'></script>
<script src='/lib/btn-copy.js'></script>
</main>
<footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
      <a href="https://github.com/UNIDY2002/" target="_blank"><i class="mdui-p-a-1 mdui-icon iconfont mdui-text-color-theme-a100">&#xe7ab;</i></a>
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    <a target="_blank" href="https://beian.miit.gov.cn/" class="mdui-text-color-theme-a100">京ICP备2021021102号-1</a>
    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802035479" class="mdui-text-color-theme-a100"><img src="/images/beian.png" style="padding-left: 1px;padding-right: 2px"/>京公网安备 11010802035479号</a>
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    &copy; 2023 | <i class="fa fa-user"></i> UNIDY
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  
<script src="https://unpkg.com/mdui@1.0.1/dist/js/mdui.js"></script>
<script src="/lib/script.js"></script>

</body>
</html>
